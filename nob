#!/usr/bin/env python3

import sys
import re
import os
import datetime

HTML_TEMPLATE = """<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{title}</title>
    <style>
        body {{ margin: 2em; width: 800px; }}
        p {{ line-height: 1.2; }}
        a, a:visited {{ color: blue; text-decoration: none; }}  
        blockquote {{ margin: 0; padding: 1em; border-left: 4px solid #ccc; background: #f9f9f9; }}
        .folded-content {{ display: none; }}
        .foldable:hover {{ cursor: pointer; background: #f5f5f5; }}
    </style>
</head>
<body>
{body}
<div style="margin-top: 4em;"><a href="index.html">^</a></div>
<script>
document.addEventListener("DOMContentLoaded", function() {{
    function getLevel(tag) {{
        return parseInt(tag.replace('H',''));
    }}
    var headings = Array.prototype.slice.call(document.querySelectorAll("h1, h2, h3, h4, h5, h6"));
    // Build fold regions: each heading points to its content elements
    for (var i = 0; i < headings.length; ++i) {{
        var h = headings[i];
        var level = getLevel(h.tagName);
        var region = [];
        var next = h.nextElementSibling;
        while (next && (!/^H[1-6]$/.test(next.tagName) || getLevel(next.tagName) > level)) {{
            region.push(next);
            next = next.nextElementSibling;
        }}
        h.classList.add("foldable");
        h.addEventListener("click", (function(region) {{
            return function() {{
                var isFolded = region.length && region[0].classList.contains("folded-content");
                region.forEach(function(el) {{
                    if (isFolded) {{
                        el.classList.remove("folded-content");
                    }} else {{
                        el.classList.add("folded-content");
                    }}
                }});
            }};
        }})(region));
    }}
}});
</script>
</body>
</html>
"""

INDEX_TEMPLATE = """<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{title}</title>
    <style>
        body {{ margin: 2em; width: 800px;}}
        a, a:visited {{ color: blue; text-decoration: none; }}
        a:hover {{ text-decoration: none; }}
        li {{ margin: 0.5em 0; }}
        .updated-date {{ color: #f5f5f5; transition: color 0.2s; }}
        a:hover .updated-date {{ color: #777; }}
    </style>
</head>
<body>
{body}
</body>
</html>
"""

def md_to_html(md_lines):
    html = []
    list_stack = []  # Track (indent_level, tag)
    in_blockquote = False
    in_codeblock = False
    codeblock_lines = []
    codeblock_fence = None
    para_buffer = []

    def close_lists_to(level):
        while list_stack and list_stack[-1][0] >= level:
            html.append("</ul>")
            list_stack.pop()

    def close_blockquote():
        nonlocal in_blockquote
        if in_blockquote:
            html.append("</blockquote>")
            in_blockquote = False

    def flush_paragraph():
        nonlocal para_buffer
        if para_buffer:
            paragraph = ' '.join(line.strip() for line in para_buffer).strip()
            if paragraph:
                html.append(f"<p>{inline_format(paragraph)}</p>")
            para_buffer = []

    def escape_html(text):
        return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    def inline_format(text):
        text = re.sub(r'!\[([^\]]*)\]\(([^)]+)\)', r'<img src="\2" alt="\1">', text)
        text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'<a href="\2">\1</a>', text)
        text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
        text = re.sub(r'__(.+?)__', r'<b>\1</b>', text)
        text = re.sub(r'\*(.+?)\*', r'<i>\1</i>', text)
        text = re.sub(r'_(.+?)_', r'<i>\1</i>', text)
        text = re.sub(r'\+\+(.+?)\+\+', r'<u>\1</u>', text)
        text = re.sub(r'`(.+?)`', r'<tt>\1</tt>', text)
        return text

    i = 0
    while i < len(md_lines):
        line = md_lines[i].rstrip('\n')

        # Fenced code block start/end
        fence_match = re.match(r'^(```|~~~)', line)
        if fence_match:
            flush_paragraph()
            close_lists_to(0)
            close_blockquote()
            in_codeblock = not in_codeblock
            if in_codeblock:
                codeblock_fence = fence_match.group(1)
                codeblock_lines = []
            else:
                html.append('<pre><tt>{}</tt></pre>'.format(
                    escape_html('\n'.join(codeblock_lines))
                ))
                codeblock_fence = None
            i += 1
            continue

        if in_codeblock:
            codeblock_lines.append(line)
            i += 1
            continue

        # Indented code block (4 spaces or tab) -- only if not a list item!
        if (line.startswith('    ') or line.startswith('\t')) and not re.match(r'^\s*([-*+])\s+', line):
            flush_paragraph()
            close_lists_to(0)
            close_blockquote()
            codeblock_lines = []
            while i < len(md_lines):
                l = md_lines[i].rstrip('\n')
                if (l.startswith('    ') or l.startswith('\t')) and not re.match(r'^\s*([-*+])\s+', l):
                    codeblock_lines.append(l[4:] if l.startswith('    ') else l[1:])
                else:
                    break
                i += 1
            html.append('<pre><tt>{}</tt></pre>'.format(
                escape_html('\n'.join(codeblock_lines))
            ))
            continue

        # Paragraph boundary: empty line
        if not line.strip():
            flush_paragraph()
            close_lists_to(0)
            close_blockquote()
            i += 1
            continue

        # Headings
        m = re.match(r'^(#{1,6})\s+(.*)', line)
        if m:
            flush_paragraph()
            close_lists_to(0)
            close_blockquote()
            level = len(m.group(1))
            html.append(f"<h{level}>{inline_format(m.group(2))}</h{level}>")
            i += 1
            continue

        # Blockquote
        if line.startswith('>'):
            flush_paragraph()
            if not in_blockquote:
                close_lists_to(0)
                html.append("<blockquote>")
                in_blockquote = True
            html.append(inline_format(line[1:].lstrip()))
            i += 1
            continue
        else:
            close_blockquote()

        # Unordered list (with nesting and bullet type)
        m = re.match(r'^(\s*)([-*+])\s+(.*)', line)
        if m:
            flush_paragraph()
            indent = len(m.group(1).replace('\t', '    '))
            bullet = m.group(2)
            content = m.group(3)

            # Open new lists or close as needed
            while list_stack and (indent < list_stack[-1][0]):
                html.append("</ul>")
                list_stack.pop()
            if not list_stack or indent > list_stack[-1][0]:
                html.append("<ul>")
                list_stack.append((indent, bullet))
            html.append(f"<li>{inline_format(content)}</li>")
            i += 1
            continue
        else:
            close_lists_to(0)

        # Otherwise, buffer for paragraph
        para_buffer.append(line)
        i += 1

    flush_paragraph()
    close_lists_to(0)
    close_blockquote()
    return '\n'.join(html)

def get_title(md_lines):
    for line in md_lines:
        m = re.match(r'^(#{1,6})\s+(.*)', line)
        if m:
            return m.group(2).strip()
    return "Document"

def convert_md_file(md_path):
    with open(md_path, 'r', encoding='utf-8') as f:
        md_lines = f.readlines()
    html_body = md_to_html(md_lines)
    title = get_title(md_lines)
    html = HTML_TEMPLATE.format(title=title, body=html_body)
    html_path = os.path.splitext(md_path)[0] + ".html"
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html)
    return html_path, title

def make_index_html(md_files):
    entries = []
    for md_file in md_files:
        html_file = os.path.splitext(md_file)[0] + ".html"
        try:
            with open(md_file, 'r', encoding='utf-8') as f:
                title = get_title(f.readlines())
        except Exception:
            title = html_file
        stat = os.stat(md_file)
        modified = datetime.datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d')
        entries.append(
            f'<li><a href="{os.path.basename(html_file)}">{title} '
            f'<span class="updated-date">[{modified}]</span></a></li>'
        )
    body = "<h1>Index</h1>\n<ul>\n" + "\n".join(entries) + "\n</ul>"
    html = INDEX_TEMPLATE.format(title="Index", body=body)
    with open("index.html", 'w', encoding='utf-8') as f:
        f.write(html)

def print_usage():
    print("Usage:")
    print("  nob -c file1.md [file2.md ...] (converts md->html)")
    print("  nob -i (creates index)")
    sys.exit(1)

if __name__ == "__main__":
    args = sys.argv[1:]
    if not args or (not ('-c' in args or '-i' in args)):
        print_usage()

    md_files = []
    make_index = False

    i = 0
    while i < len(args):
        if args[i] == '-c':
            i += 1
            while i < len(args) and not args[i].startswith('-'):
                if args[i].endswith('.md') and os.path.isfile(args[i]):
                    md_files.append(args[i])
                else:
                    print(f"Warning: {args[i]} is not a markdown file or does not exist.")
                i += 1
        elif args[i] == '-i':
            make_index = True
            i += 1
        else:
            print(f"Unknown argument: {args[i]}")
            print_usage()

    # Convert markdown files to html
    for md_file in md_files:
        convert_md_file(md_file)

    # If -i, make index.html of all markdown files in the directory
    if make_index:
        # If -c was used, use only those files; otherwise, all .md files in cwd
        if md_files:
            md_files_for_index = md_files
        else:
            md_files_for_index = [f for f in os.listdir('.') if f.endswith('.md') and os.path.isfile(f)]
        make_index_html(md_files_for_index)
